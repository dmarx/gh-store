---
File: typescript/src/__tests__/cache.test.ts
---
// src/__tests__/cache.test.ts
import { jest, describe, it, expect, beforeEach } from '@jest/globals';
import { IssueCache } from '../cache';

describe('IssueCache', () => {
  let cache: IssueCache;
  
  beforeEach(() => {
    cache = new IssueCache();
  });

  it('should store and retrieve issue numbers', () => {
    const metadata = {
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    cache.set('test-1', 123, metadata);
    expect(cache.get('test-1')).toBe(123);
  });

  it('should respect maxSize limit', () => {
    const cache = new IssueCache({ maxSize: 2 });
    const metadata = {
      createdAt: new Date(),
      updatedAt: new Date()
    };

    cache.set('test-1', 123, metadata);
    cache.set('test-2', 456, metadata);
    cache.set('test-3', 789, metadata); // Should evict oldest

    expect(cache.get('test-1')).toBeUndefined();
    expect(cache.get('test-2')).toBe(456);
    expect(cache.get('test-3')).toBe(789);
  });

  it('should respect TTL', () => {
    jest.useFakeTimers();
    const cache = new IssueCache({ ttl: 1000 }); // 1 second TTL
    const metadata = {
      createdAt: new Date(),
      updatedAt: new Date()
    };

    cache.set('test-1', 123, metadata);
    expect(cache.get('test-1')).toBe(123);

    // Advance time past TTL
    jest.advanceTimersByTime(1001);
    expect(cache.get('test-1')).toBeUndefined();

    jest.useRealTimers();
  });

  it('should clear all entries', () => {
    const metadata = {
      createdAt: new Date(),
      updatedAt: new Date()
    };

    cache.set('test-1', 123, metadata);
    cache.set('test-2', 456, metadata);
    
    cache.clear();
    
    expect(cache.get('test-1')).toBeUndefined();
    expect(cache.get('test-2')).toBeUndefined();
    expect(cache.getStats().size).toBe(0);
  });

  it('should report correct stats', () => {
    const cache = new IssueCache({ maxSize: 100, ttl: 3600000 });
    const metadata = {
      createdAt: new Date(),
      updatedAt: new Date()
    };

    cache.set('test-1', 123, metadata);
    cache.set('test-2', 456, metadata);

    const stats = cache.getStats();
    expect(stats.size).toBe(2);
    expect(stats.maxSize).toBe(100);
    expect(stats.ttl).toBe(3600000);
  });

  it('should correctly determine if refresh is needed', () => {
    const createdAt = new Date('2025-01-01');
    const updatedAt = new Date('2025-01-02');
    const metadata = { createdAt, updatedAt };

    cache.set('test-1', 123, metadata);

    // No refresh needed for same or older update time
    expect(cache.shouldRefresh('test-1', updatedAt)).toBe(false);
    expect(cache.shouldRefresh('test-1', new Date('2025-01-01'))).toBe(false);

    // Refresh needed for newer update time
    expect(cache.shouldRefresh('test-1', new Date('2025-01-03'))).toBe(true);

    // Always refresh for non-existent entries
    expect(cache.shouldRefresh('nonexistent', new Date())).toBe(true);
  });
});



---
File: typescript/src/__tests__/canonical.test.ts
---
// typescript/src/__tests__/canonical.test.ts

import { describe, it, expect, beforeEach } from '@jest/globals';
import { CanonicalStoreClient } from '../canonical';
import { LabelNames } from '../types';
import fetchMock from 'jest-fetch-mock';

// Create a test version by extending and adding protected methods for exposure
class TestCanonicalStoreClient extends CanonicalStoreClient {
  // Override fetchFromGitHub to make it accessible
  public testFetchFromGitHub<T>(path: string, options?: RequestInit & { params?: Record<string, string> }): Promise<T> {
    return this.fetchFromGitHub<T>(path, options);
  }
  
  // We need to recreate these protected methods for testing
  public testExtractObjectIdFromLabels(issue: { labels: Array<{ name: string }> }): string {
    return this._extractObjectIdFromLabels(issue);
  }
}

describe('CanonicalStoreClient', () => {
  const token = 'test-token';
  const repo = 'owner/repo';
  let client: TestCanonicalStoreClient;

  beforeEach(() => {
    fetchMock.resetMocks();
    // Create the client without passing cache - it's not in CanonicalStoreConfig
    client = new TestCanonicalStoreClient(token, repo);
  });

  describe('resolveCanonicalObjectId', () => {
    it('should resolve direct object ID', async () => {
      // Mock to find the object directly (not an alias)
      fetchMock.mockResponseOnce(JSON.stringify([])); // No issues with alias labels

      const result = await client.resolveCanonicalObjectId('test-object');
      expect(result).toBe('test-object');
    });

    it('should resolve alias to canonical ID', async () => {
      // Mock to find an issue with alias label
      const mockIssue = {
        number: 123,
        labels: [
          { name: `${LabelNames.UID_PREFIX}test-alias` },
          { name: `${LabelNames.ALIAS_TO_PREFIX}test-canonical` }
        ]
      };
      fetchMock.mockResponseOnce(JSON.stringify([mockIssue]));

      const result = await client.resolveCanonicalObjectId('test-alias');
      expect(result).toBe('test-canonical');
    });

    it('should follow alias chain but prevent infinite loops', async () => {
      // Mock the first lookup (test-alias-1 -> test-alias-2)
      const mockIssue1 = {
        number: 123,
        labels: [
          { name: `${LabelNames.UID_PREFIX}test-alias-1` },
          { name: `${LabelNames.ALIAS_TO_PREFIX}test-alias-2` }
        ]
      };
      fetchMock.mockResponseOnce(JSON.stringify([mockIssue1]));

      // Mock the second lookup (test-alias-2 -> test-canonical)
      const mockIssue2 = {
        number: 124,
        labels: [
          { name: `${LabelNames.UID_PREFIX}test-alias-2` },
          { name: `${LabelNames.ALIAS_TO_PREFIX}test-canonical` }
        ]
      };
      fetchMock.mockResponseOnce(JSON.stringify([mockIssue2]));

      // Mock the last lookup (no more aliases)
      fetchMock.mockResponseOnce(JSON.stringify([]));

      const result = await client.resolveCanonicalObjectId('test-alias-1');
      expect(result).toBe('test-canonical');
    });

    it('should detect and break circular references', async () => {
      // Mock circular references (test-alias-a -> test-alias-b -> test-alias-a)
      const mockIssueA = {
        number: 123,
        labels: [
          { name: `${LabelNames.UID_PREFIX}test-alias-a` },
          { name: `${LabelNames.ALIAS_TO_PREFIX}test-alias-b` }
        ]
      };
      fetchMock.mockResponseOnce(JSON.stringify([mockIssueA]));

      const mockIssueB = {
        number: 124,
        labels: [
          { name: `${LabelNames.UID_PREFIX}test-alias-b` },
          { name: `${LabelNames.ALIAS_TO_PREFIX}test-alias-a` }
        ]
      };
      fetchMock.mockResponseOnce(JSON.stringify([mockIssueB]));

      // We should detect the circularity and return test-alias-b (the first level)
      const result = await client.resolveCanonicalObjectId('test-alias-a');
      expect(result).toBe('test-alias-a'); // Return original ID on circular reference
    });
  });

  describe('getObject with canonicalization', () => {
    it('should resolve and use canonical ID by default', async () => {
      // Mock to find the alias
      const mockAliasIssue = {
        number: 123,
        labels: [
          { name: `${LabelNames.UID_PREFIX}test-alias` },
          { name: `${LabelNames.ALIAS_TO_PREFIX}test-canonical` }
        ]
      };
      fetchMock.mockResponseOnce(JSON.stringify([mockAliasIssue]));

      // Mock for empty response (no more aliases)
      fetchMock.mockResponseOnce(JSON.stringify([]));

      // Mock for finding canonical issue
      const mockCanonicalIssue = {
        number: 456,
        body: JSON.stringify({ value: 42 }),
        created_at: '2025-01-01T00:00:00Z',
        updated_at: '2025-01-02T00:00:00Z',
        labels: [
          { name: LabelNames.STORED_OBJECT },
          { name: `${LabelNames.UID_PREFIX}test-canonical` }
        ]
      };
      fetchMock.mockResponseOnce(JSON.stringify([mockCanonicalIssue]));

      // Mock for comments count
      fetchMock.mockResponseOnce(JSON.stringify([]));

      const result = await client.getObject('test-alias');
      
      expect(result.meta.objectId).toBe('test-canonical');
      expect(result.data).toEqual({ value: 42 });
    });

    it('should get alias directly when canonicalize=false', async () => {
      // Mock for direct lookup with UID label
      const mockIssues = [{
        number: 123,
        body: JSON.stringify({ alias_value: 'direct' }),
        created_at: '2025-01-01T00:00:00Z',
        updated_at: '2025-01-02T00:00:00Z',
        labels: [
          { name: LabelNames.STORED_OBJECT },
          { name: `${LabelNames.UID_PREFIX}test-alias` },
          { name: `${LabelNames.ALIAS_TO_PREFIX}test-canonical` }
        ]
      }];
      fetchMock.mockResponseOnce(JSON.stringify(mockIssues));

      // Mock for comments count
      fetchMock.mockResponseOnce(JSON.stringify([]));

      const result = await client.getObject('test-alias', { canonicalize: false });
      
      expect(result.meta.objectId).toBe('test-alias');
      expect(result.data).toEqual({ alias_value: 'direct' });
    });
  });

  describe('createAlias', () => {
    it('should create alias relationship between objects', async () => {
      // Mock for source object lookup
      const mockSourceIssues = [{
        number: 123,
        labels: [
          { name: LabelNames.STORED_OBJECT },
          { name: `${LabelNames.UID_PREFIX}source-id` }
        ]
      }];
      fetchMock.mockResponseOnce(JSON.stringify(mockSourceIssues));

      // Mock for target object lookup
      const mockTargetIssues = [{
        number: 456,
        labels: [
          { name: LabelNames.STORED_OBJECT },
          { name: `${LabelNames.UID_PREFIX}target-id` }
        ]
      }];
      fetchMock.mockResponseOnce(JSON.stringify(mockTargetIssues));

      // Mock for existing labels check
      fetchMock.mockResponseOnce(JSON.stringify([
        { name: LabelNames.STORED_OBJECT },
        { name: `${LabelNames.UID_PREFIX}source-id` }
      ]));

      // Mock for creating alias label
      fetchMock.mockResponseOnce(JSON.stringify({}));

      // Mock for adding label to issue
      fetchMock.mockResponseOnce(JSON.stringify({}));

      const result = await client.createAlias('source-id', 'target-id');
      
      expect(result.success).toBe(true);
      expect(result.sourceId).toBe('source-id');
      expect(result.targetId).toBe('target-id');

      // Verify correct URL for the label creation
      expect(fetchMock.mock.calls[3][0]).toContain('/labels');
    });

    it('should reject if source is already an alias', async () => {
      // Mock for source object lookup
      const mockSourceIssues = [{
        number: 123,
        labels: [
          { name: LabelNames.STORED_OBJECT },
          { name: `${LabelNames.UID_PREFIX}source-id` }
        ]
      }];
      fetchMock.mockResponseOnce(JSON.stringify(mockSourceIssues));

      // Mock for target object lookup
      const mockTargetIssues = [{
        number: 456,
        labels: [
          { name: LabelNames.STORED_OBJECT },
          { name: `${LabelNames.UID_PREFIX}target-id` }
        ]
      }];
      fetchMock.mockResponseOnce(JSON.stringify(mockTargetIssues));

      // Mock for existing labels check - already has an alias
      fetchMock.mockResponseOnce(JSON.stringify([
        { name: LabelNames.STORED_OBJECT },
        { name: `${LabelNames.UID_PREFIX}source-id` },
        { name: `${LabelNames.ALIAS_TO_PREFIX}other-id` }
      ]));

      await expect(client.createAlias('source-id', 'target-id'))
        .rejects
        .toThrow('Object source-id is already an alias');
    });
  });

  describe('findAliases', () => {
    it('should find all aliases in the repository', async () => {
      // Mock for all alias issues
      const mockIssues = [
        {
          labels: [
            { name: `${LabelNames.UID_PREFIX}alias-1` },
            { name: `${LabelNames.ALIAS_TO_PREFIX}canonical-1` }
          ]
        },
        {
          labels: [
            { name: `${LabelNames.UID_PREFIX}alias-2` },
            { name: `${LabelNames.ALIAS_TO_PREFIX}canonical-2` }
          ]
        }
      ];
      fetchMock.mockResponseOnce(JSON.stringify(mockIssues));

      const aliases = await client.findAliases();
      
      // Should find both aliases
      expect(Object.keys(aliases).length).toBe(2);
      expect(aliases['alias-1']).toBe('canonical-1');
      expect(aliases['alias-2']).toBe('canonical-2');
    });

    it('should find aliases for a specific object', async () => {
      // Mock for specific alias issues
      const mockIssues = [
        {
          labels: [
            { name: `${LabelNames.UID_PREFIX}alias-1` },
            { name: `${LabelNames.ALIAS_TO_PREFIX}target-id` }
          ]
        },
        {
          labels: [
            { name: `${LabelNames.UID_PREFIX}alias-2` },
            { name: `${LabelNames.ALIAS_TO_PREFIX}target-id` }
          ]
        }
      ];
      fetchMock.mockResponseOnce(JSON.stringify(mockIssues));

      const aliases = await client.findAliases('target-id');
      
      // Should find both aliases for the target
      expect(Object.keys(aliases).length).toBe(2);
      expect(aliases['alias-1']).toBe('target-id');
      expect(aliases['alias-2']).toBe('target-id');
    });
  });
});



---
File: typescript/src/__tests__/client.test.ts
---
// typescript/src/__tests__/client.test.ts

// In typescript/src/__tests__/client.test.ts:
import { describe, it, expect, beforeEach } from '@jest/globals';
import { GitHubStoreClient } from '../client';
import { LabelNames } from '../types'; // Add this import
import { CLIENT_VERSION } from '../version';
import fetchMock from 'jest-fetch-mock';

describe('GitHubStoreClient', () => {
  const token = 'test-token';
  const repo = 'owner/repo';
  let client: GitHubStoreClient;

  beforeEach(() => {
    fetchMock.resetMocks();
    client = new GitHubStoreClient(token, repo, {
      cache: {
        maxSize: 100,
        ttl: 3600000
      }
    });
  });

  describe('getObject with cache', () => {
    const mockIssue = {
      number: 123,
      body: JSON.stringify({ key: 'value' }),
      created_at: '2025-01-01T00:00:00Z',
      updated_at: '2025-01-02T00:00:00Z',
      labels: [
        { name: 'stored-object' },
        { name: 'UID:test-object' }
      ]
    };

    it('should use cached issue number on subsequent requests', async () => {
      // First request - should query by labels
      fetchMock
        .mockResponseOnce(JSON.stringify([mockIssue])) // Initial labels query
        .mockResponseOnce(JSON.stringify([])); // Comments query for version

      await client.getObject('test-object');
      expect(fetchMock.mock.calls[0][0]).toContain('/issues?labels=');

      // Reset mock to verify cache hit
      fetchMock.resetMocks();
      fetchMock
        .mockResponseOnce(JSON.stringify(mockIssue)) // Direct issue fetch
        .mockResponseOnce(JSON.stringify([])); // Comments query for version

      await client.getObject('test-object');
      
      // Should use direct issue number fetch instead of labels query
      expect(fetchMock.mock.calls[0][0]).toContain('/issues/123');
    });

    it('should fall back to label query if cached issue is not found', async () => {
      // First request succeeds
      fetchMock
        .mockResponseOnce(JSON.stringify([mockIssue]))
        .mockResponseOnce(JSON.stringify([]));

      await client.getObject('test-object');

      // Reset mock to simulate deleted issue
      fetchMock.resetMocks();
      fetchMock
        .mockResponseOnce('', { status: 404 }) // Cached issue not found
        .mockResponseOnce(JSON.stringify([mockIssue])) // Fallback label query
        .mockResponseOnce(JSON.stringify([])); // Comments query

      await client.getObject('test-object');

      // Should have attempted direct fetch, then fallen back to labels
      expect(fetchMock.mock.calls[0][0]).toContain('/issues/123');
      expect(fetchMock.mock.calls[1][0]).toContain('/issues?labels=');
    });

    it('should fetch and parse object correctly', async () => {
      const mockComments = [{ id: 1 }, { id: 2 }];

      fetchMock
        .mockResponseOnce(JSON.stringify([mockIssue]))
        .mockResponseOnce(JSON.stringify(mockComments));

      const obj = await client.getObject('test-object');

      expect(obj.meta.objectId).toBe('test-object');
      expect(obj.meta.version).toBe(3);
      expect(obj.data).toEqual({ key: 'value' });
    });
  });
  
  // In client.test.ts, update the createObject test:
  describe('createObject', () => {
    it('should create new object with initial state and metadata', async () => {
      const mockIssue = {
        number: 456,
        created_at: '2025-01-01T00:00:00Z',
        updated_at: '2025-01-01T00:00:00Z',
        html_url: 'https://github.com/owner/repo/issues/456',
        body: JSON.stringify({ test: 'data' }),
        labels: [
          { name: 'stored-object' },
          { name: 'UID:test-object' }
        ]
      };
  
      const mockComment = { id: 123 };
  
      fetchMock
        .mockResponseOnce(JSON.stringify(mockIssue)) // Create issue
        .mockResponseOnce(JSON.stringify(mockComment)) // Create comment
        .mockResponseOnce(JSON.stringify({ id: 1 })) // Add processed reaction
        .mockResponseOnce(JSON.stringify({ id: 2 })) // Add initial state reaction
        .mockResponseOnce(JSON.stringify({ state: 'closed' })); // Close issue
  
      const data = { test: 'data' };
      const obj = await client.createObject('test-object', data);
  
      expect(obj.meta.objectId).toBe('test-object');
      expect(obj.meta.version).toBe(1);
      expect(obj.data).toEqual(data);
  
      // Verify issue creation includes all required labels
      expect(fetchMock.mock.calls[0][1]?.body).toContain('"stored-object"');
      expect(fetchMock.mock.calls[0][1]?.body).toContain('"UID:test-object"');
      expect(fetchMock.mock.calls[0][1]?.body).toContain('"gh-store"'); // Verify gh-store label is included
  
      // Verify initial state comment with metadata
      const commentBody = JSON.parse(JSON.parse(fetchMock.mock.calls[1][1]?.body as string).body);
      expect(commentBody.type).toBe('initial_state');
      expect(commentBody._data).toEqual(data);
      expect(commentBody._meta).toBeDefined();
      expect(commentBody._meta.client_version).toBe(CLIENT_VERSION);
      expect(commentBody._meta.timestamp).toBeDefined();
      expect(commentBody._meta.update_mode).toBe('append');
    });
  });
  
  // Add a specific test to verify label structure:
  it('should include gh-store label when creating objects', async () => {
    const mockIssue = {
      number: 789,
      created_at: '2025-01-01T00:00:00Z',
      updated_at: '2025-01-01T00:00:00Z',
      html_url: 'https://github.com/owner/repo/issues/789',
      body: '{}',
      labels: []
    };
    
    // Mock all the required responses
    fetchMock
      .mockResponseOnce(JSON.stringify(mockIssue))
      .mockResponseOnce(JSON.stringify({ id: 1 }))
      .mockResponseOnce(JSON.stringify({ id: 1 }))
      .mockResponseOnce(JSON.stringify({ id: 2 }))
      .mockResponseOnce(JSON.stringify({ state: 'closed' }));
    
    await client.createObject('test-label-object', {});
    
    // Parse the request body from the first call (create issue)
    const requestBody = JSON.parse(fetchMock.mock.calls[0][1]?.body as string);
    
    // Verify the labels array includes all required labels
    expect(requestBody.labels).toContain(LabelNames.GH_STORE);
    expect(requestBody.labels).toContain('stored-object');
    expect(requestBody.labels).toContain('UID:test-label-object');
    expect(requestBody.labels.length).toBe(3); // Should only be these three labels
  });

  describe('updateObject', () => {
    it('should add update comment with metadata', async () => {
      const mockIssue = {
        number: 1,
        state: 'closed',
        body: JSON.stringify({ key: 'value' }),
        created_at: '2025-01-01T00:00:00Z',
        updated_at: '2025-01-02T00:00:00Z',
        labels: [
          { name: 'stored-object' },
          { name: 'UID:test-object' }
        ]
      };

      fetchMock
        .mockResponseOnce(JSON.stringify([mockIssue])) // Get issue
        .mockResponseOnce(JSON.stringify({ id: 123 })) // Add comment
        .mockResponseOnce(JSON.stringify({ state: 'open' })) // Reopen issue
        .mockResponseOnce(JSON.stringify([mockIssue])) // Get updated object
        .mockResponseOnce(JSON.stringify([])); // Get comments for version

      const changes = { key: 'updated' };
      await client.updateObject('test-object', changes);

      // Verify update comment with metadata
      const commentPayload = JSON.parse(fetchMock.mock.calls[1][1]?.body as string);
      const commentBody = JSON.parse(commentPayload.body);
      expect(commentBody._data).toEqual(changes);
      expect(commentBody._meta).toBeDefined();
      expect(commentBody._meta.client_version).toBe(CLIENT_VERSION);
      expect(commentBody._meta.timestamp).toBeDefined();
      expect(commentBody._meta.update_mode).toBe('append');
    });
  });

  describe('getObjectHistory', () => {
    it('should return full object history with metadata', async () => {
      const mockIssue = {
        number: 1,
        labels: [
          { name: 'stored-object' },
          { name: 'UID:test-object' }
        ]
      };

      const mockComments = [
        {
          id: 1,
          created_at: '2025-01-01T00:00:00Z',
          body: JSON.stringify({
            type: 'initial_state',
            _data: { status: 'new' },
            _meta: {
              client_version: CLIENT_VERSION,
              timestamp: '2025-01-01T00:00:00Z',
              update_mode: 'append'
            }
          })
        },
        {
          id: 2,
          created_at: '2025-01-02T00:00:00Z',
          body: JSON.stringify({
            _data: { status: 'updated' },
            _meta: {
              client_version: CLIENT_VERSION,
              timestamp: '2025-01-02T00:00:00Z',
              update_mode: 'append'
            }
          })
        }
      ];

      fetchMock
        .mockResponseOnce(JSON.stringify([mockIssue]))
        .mockResponseOnce(JSON.stringify(mockComments));

      const history = await client.getObjectHistory('test-object');

      expect(history).toHaveLength(2);
      expect(history[0].type).toBe('initial_state');
      expect(history[0].data).toEqual({ status: 'new' });
      expect(history[1].type).toBe('update');
      expect(history[1].data).toEqual({ status: 'updated' });
    });
  });

  describe('API Error Handling', () => {
    it('should throw error on API failure', async () => {
      fetchMock.mockResponseOnce('', { 
        status: 500,
        statusText: 'Internal Server Error'
      });

      await expect(client.getObject('test-obj'))
        .rejects
        .toThrow('GitHub API error: 500');
    });

    it('should handle malformed JSON responses', async () => {
      fetchMock.mockResponseOnce('invalid json');

      await expect(client.getObject('test-obj'))
        .rejects
        .toThrow();
    });
  });

  describe('listAll', () => {
    it('should handle empty repository', async () => {
      fetchMock.mockResponseOnce(JSON.stringify([]));

      const objects = await client.listAll();
      expect(Object.keys(objects)).toHaveLength(0);
    });

    it('should handle invalid issue data', async () => {
      const mockIssues = [{
        number: 1,
        body: 'invalid json',
        labels: [
          { name: 'stored-object' },
          { name: 'UID:test-1' }
        ],
        created_at: '2025-01-01T00:00:00Z',
        updated_at: '2025-01-02T00:00:00Z'
      }];

      fetchMock.mockResponseOnce(JSON.stringify(mockIssues));

      const objects = await client.listAll();
      expect(Object.keys(objects)).toHaveLength(0);
    });

    it('should skip issues without proper labels', async () => {
      const mockIssues = [{
        number: 1,
        body: JSON.stringify({ test: 'data' }),
        labels: [
          { name: 'stored-object' }  // Missing UID label
        ],
        created_at: '2025-01-01T00:00:00Z',
        updated_at: '2025-01-02T00:00:00Z'
      }];

      fetchMock.mockResponseOnce(JSON.stringify(mockIssues));

      const objects = await client.listAll();
      expect(Object.keys(objects)).toHaveLength(0);
    });
  });

  describe('listUpdatedSince', () => {
    it('should handle no updates', async () => {
      const timestamp = new Date('2025-01-01T00:00:00Z');
      fetchMock.mockResponseOnce(JSON.stringify([]));

      const objects = await client.listUpdatedSince(timestamp);
      expect(Object.keys(objects)).toHaveLength(0);
    });

    it('should ignore updates before timestamp', async () => {
      const timestamp = new Date('2025-01-02T00:00:00Z');
      const mockIssues = [{
        number: 1,
        body: JSON.stringify({ test: 'data' }),
        created_at: '2025-01-01T00:00:00Z',
        updated_at: '2025-01-01T12:00:00Z',  // Before timestamp
        labels: [
          { name: 'stored-object' },
          { name: 'UID:test-1' }
        ]
      }];

      fetchMock.mockResponseOnce(JSON.stringify(mockIssues));

      const objects = await client.listUpdatedSince(timestamp);
      expect(Object.keys(objects)).toHaveLength(0);
    });
  });

  describe('getObjectHistory', () => {
    it('should handle missing object', async () => {
      fetchMock.mockResponseOnce(JSON.stringify([]));

      await expect(client.getObjectHistory('nonexistent'))
        .rejects
        .toThrow('No object found with ID: nonexistent');
    });

    it('should handle invalid comments', async () => {
      const mockIssue = {
        number: 1,
        labels: [
          { name: 'stored-object' },
          { name: 'UID:test-object' }
        ]
      };

      const mockComments = [
        {
          id: 1,
          created_at: '2025-01-01T00:00:00Z',
          body: 'invalid json'  // Invalid comment
        },
        {
          id: 2,
          created_at: '2025-01-02T00:00:00Z',
          body: JSON.stringify({
            _data: { status: 'valid' },
            _meta: {
              client_version: CLIENT_VERSION,
              timestamp: '2025-01-02T00:00:00Z',
              update_mode: 'append'
            }
          })
        }
      ];

      fetchMock
        .mockResponseOnce(JSON.stringify([mockIssue]))
        .mockResponseOnce(JSON.stringify(mockComments));

      const history = await client.getObjectHistory('test-object');

      expect(history).toHaveLength(1);  // Only valid comment included
      expect(history[0].data).toEqual({ status: 'valid' });
    });

    it('should process legacy format comments', async () => {
      const mockIssue = {
        number: 1,
        labels: [
          { name: 'stored-object' },
          { name: 'UID:test-object' }
        ]
      };

      const mockComments = [
        {
          id: 1,
          created_at: '2025-01-01T00:00:00Z',
          body: JSON.stringify({ status: 'legacy' })  // Legacy format
        }
      ];

      fetchMock
        .mockResponseOnce(JSON.stringify([mockIssue]))
        .mockResponseOnce(JSON.stringify(mockComments));

      const history = await client.getObjectHistory('test-object');

      expect(history).toHaveLength(1);
      expect(history[0].type).toBe('update');
      expect(history[0].data).toEqual({ status: 'legacy' });
    });
  });
});



---
File: typescript/src/__tests__/public-mode.test.ts
---
// typescript/src/__tests__/public-mode.test.ts
import { describe, it, expect, beforeEach } from '@jest/globals';
import { GitHubStoreClient } from '../client';
import fetchMock from 'jest-fetch-mock';

describe('GitHubStoreClient in Public Mode', () => {
  let client: GitHubStoreClient;
  const repo = 'owner/repo';

  beforeEach(() => {
    fetchMock.resetMocks();
    // Initialize in public mode (no token)
    client = new GitHubStoreClient(null, repo);
  });

  it('should correctly identify as public mode', () => {
    expect(client.isPublic()).toBe(true);
  });

  it('should fetch objects without authentication headers', async () => {
    const mockIssue = {
      number: 123,
      body: JSON.stringify({ key: 'value' }),
      created_at: '2025-01-01T00:00:00Z',
      updated_at: '2025-01-02T00:00:00Z',
      labels: [
        { name: 'stored-object' },
        { name: 'UID:test-object' }
      ]
    };

    fetchMock
      .mockResponseOnce(JSON.stringify([mockIssue]))
      .mockResponseOnce(JSON.stringify([]));

    await client.getObject('test-object');
    
    // Verify no auth header was sent
    expect(fetchMock.mock.calls[0][1]?.headers).not.toHaveProperty('Authorization');
  });

  it('should reject create operations in public mode', async () => {
    await expect(client.createObject('test-object', { key: 'value' }))
      .rejects
      .toThrow('Authentication required for creating objects');
  });

  it('should reject update operations in public mode', async () => {
    await expect(client.updateObject('test-object', { key: 'value' }))
      .rejects
      .toThrow('Authentication required for updating objects');
  });

  it('should fetch object history in public mode', async () => {
    const mockIssue = {
      number: 123,
      labels: [
        { name: 'stored-object' },
        { name: 'UID:test-object' }
      ]
    };

    const mockComments = [
      {
        id: 1,
        created_at: '2025-01-01T00:00:00Z',
        body: JSON.stringify({
          type: 'initial_state',
          _data: { status: 'new' },
          _meta: {
            client_version: '0.9.0',
            timestamp: '2025-01-01T00:00:00Z',
            update_mode: 'append'
          }
        })
      }
    ];

    fetchMock
      .mockResponseOnce(JSON.stringify([mockIssue]))
      .mockResponseOnce(JSON.stringify(mockComments));

    const history = await client.getObjectHistory('test-object');
    
    expect(history).toHaveLength(1);
    expect(history[0].type).toBe('initial_state');
    expect(history[0].data).toEqual({ status: 'new' });
    
    // Verify no auth header was sent
    expect(fetchMock.mock.calls[0][1]?.headers).not.toHaveProperty('Authorization');
  });
});


