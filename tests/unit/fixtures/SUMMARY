---
File: tests/unit/fixtures/__init__.py
---




---
File: tests/unit/fixtures/canonical.py
---
# tests/unit/fixtures/canonical.py
"""Fixtures for canonicalization tests"""

import json
from datetime import datetime, timezone
import pytest
from unittest.mock import Mock, patch, MagicMock

from gh_store.tools.canonicalize import CanonicalStore, LabelNames

@pytest.fixture
def mock_canonical_store():
    """Create a mock for CanonicalStore class."""
    with patch('gh_store.cli.commands.CanonicalStore') as mock_canonical:
        canonical_instance = Mock()
        mock_canonical.return_value = canonical_instance
        
        # Mock commonly used methods
        canonical_instance.find_aliases.return_value = {"alias-obj": "canonical-obj"}
        
        yield mock_canonical

@pytest.fixture
def mock_labels_response():
    """Mock the response for get_labels to return iterable labels."""
    labels = [
        Mock(name="stored-object"),
        Mock(name="deprecated-object"),
        Mock(name="UID:test-123")
    ]
    return labels

@pytest.fixture
def canonical_store_with_mocks(mock_repo_factory, default_config, mock_labels_response):
    """Create a CanonicalStore instance with mocked repo and methods."""
    # Create mock repo
    repo = mock_repo_factory(
        name="owner/repo",
        owner_login="repo-owner",
        owner_type="User",
        labels=["stored-object", "deprecated-object"]
    )
    
    # Setup get_labels to return iterable
    repo.get_labels.return_value = mock_labels_response
    
    # Create CanonicalStore with mocked repo
    with patch('gh_store.core.store.Github') as mock_gh:
        mock_gh.return_value.get_repo.return_value = repo
        
        store = CanonicalStore(token="fake-token", repo="owner/repo")
        store.repo = repo
        store.access_control.repo = repo
        store.config = default_config
        
        # Mock common methods
        store._extract_comment_metadata = Mock(side_effect=lambda comment, issue_number, object_id: {
            "data": json.loads(comment.body) if hasattr(comment, 'body') else {},
            "timestamp": getattr(comment, 'created_at', datetime.now(timezone.utc)),
            "id": getattr(comment, 'id', 1),
            "source_issue": issue_number,
            "source_object_id": object_id
        })
        
        # Setup for find_duplicates
        store.repo.get_issues = Mock(return_value=[])
        
        # Mock methods to avoid real API calls
        store._ensure_special_labels = Mock()
        
        return store

@pytest.fixture
def mock_issue_with_initial_state(mock_issue_factory, mock_comment_factory):
    """Create a mock issue with initial state for canonicalization tests."""
    # Create initial state comment
    initial_comment = mock_comment_factory(
        body={
            "type": "initial_state",
            "_data": {"name": "test", "value": 42},
            "_meta": {
                "client_version": "0.7.0",
                "timestamp": "2025-01-01T00:00:00Z",
                "update_mode": "append",
                "issue_number": 123  # Add issue number
            }
        },
        comment_id=1,
        created_at=datetime(2025, 1, 1, tzinfo=timezone.utc)
    )
    
    # Create issue with initial state comment
    return mock_issue_factory(
        number=123,
        body=json.dumps({"name": "test", "value": 42}),
        labels=["stored-object", "UID:metrics"],
        comments=[initial_comment]
    )



---
File: tests/unit/fixtures/cli.py
---
# tests/unit/fixtures/cli.py
"""CLI-specific fixtures for gh-store unit tests."""

import os
import sys
import logging
from pathlib import Path
from datetime import datetime, timedelta, timezone
import json
import pytest
from unittest.mock import Mock, patch
from loguru import logger

from gh_store.__main__ import CLI

@pytest.fixture(autouse=True)
def cli_env_vars(monkeypatch):
    """Setup environment variables for CLI testing."""
    monkeypatch.setenv('GITHUB_TOKEN', 'test-token')
    monkeypatch.setenv('GITHUB_REPOSITORY', 'owner/repo')
    yield

@pytest.fixture
def mock_config(tmp_path):
    """Create a mock config file for testing."""
    config_dir = tmp_path / ".config" / "gh-store"
    config_dir.mkdir(parents=True)
    config_path = config_dir / "config.yml"
    
    # Create default config
    default_config = """
store:
  base_label: "stored-object"
  uid_prefix: "UID:"
  reactions:
    processed: "+1"
    initial_state: "rocket"
  retries:
    max_attempts: 3
    backoff_factor: 2
  rate_limit:
    max_requests_per_hour: 1000
  log:
    level: "INFO"
    format: "{time} | {level} | {message}"
"""
    config_path.write_text(default_config)
    return config_path

@pytest.fixture
def mock_gh_repo():
    """Create a mocked GitHub repo for testing."""
    mock_repo = Mock()
    with patch('gh_store.core.store.Github') as MockGithub:
        # Setup mock repo
        mock_repo = Mock()
        mock_repo.get_issue.return_value = Mock(state="closed")
        mock_repo.get_issues.return_value = []
        mock_repo.owner = Mock(login="owner", type="User")
        
        # Set up mock Github client
        MockGithub.return_value.get_repo.return_value = mock_repo
        yield mock_repo


class InterceptHandler(logging.Handler):
    def emit(self, record):
        # Try to find caller's module path
        try:
            frame = logging.currentframe()
            depth = 6  # Adjust if needed to find the correct caller
            while frame and depth > 0:
                frame = frame.f_back
                depth -= 1
            module_path = frame.f_code.co_filename if frame else ""
            function_name = frame.f_code.co_name if frame else ""
        except (AttributeError, ValueError):
            module_path = ""
            function_name = ""

        # Safely format the message
        try:
            msg = self.format(record)
        except Exception:
            msg = record.getMessage()

        # Write directly to caplog's handler instead of going through loguru
        logging.getLogger(record.name).handle(
            logging.LogRecord(
                name=record.name,
                level=record.levelno,
                pathname=module_path,
                lineno=record.lineno,
                msg=msg,
                args=(),
                exc_info=record.exc_info,
                func=function_name
            )
        )

# tests/unit/fixtures/cli.py - Update logging setup

@pytest.fixture(autouse=True)
def setup_loguru(caplog):
    """Configure loguru for testing with pytest caplog."""
    # Remove any existing handlers
    logger.remove()
    
    # Set up caplog
    caplog.set_level(logging.INFO)
    
    # Add a test handler that writes directly to caplog
    def log_to_caplog(message):
        logging.getLogger().info(message)
    
    handler_id = logger.add(log_to_caplog, format="{message}")
    
    yield
    
    # Cleanup
    logger.remove(handler_id)

@pytest.fixture
def mock_cli(mock_config, mock_gh_repo):
    """Create a CLI instance with mocked dependencies."""
    with patch('gh_store.cli.commands.ensure_config_exists') as mock_ensure:  # Updated path
        cli = CLI()
        # Mock HOME to point to our test config
        with patch.dict(os.environ, {'HOME': str(mock_config.parent.parent.parent)}):
            yield cli

@pytest.fixture
def mock_store_response():
    """Mock common GitHubStore responses."""
    mock_obj = Mock()
    mock_obj.meta = Mock(
        object_id="test-123",
        issue_number=42,  # Added issue_number field
        created_at=datetime(2025, 1, 1, tzinfo=timezone.utc),
        updated_at=datetime(2025, 1, 2, tzinfo=timezone.utc),
        version=1
    )
    mock_obj.data = {"name": "test", "value": 42}
    return mock_obj

@pytest.fixture
def mock_stored_objects():
    """Create mock stored objects for testing."""
    objects = []
    for i in range(1, 3):
        mock_obj = Mock()
        mock_obj.meta = Mock(
            object_id=f"test-obj-{i}",
            issue_number=100 + i,  # Added issue_number field
            created_at=datetime(2025, 1, i, tzinfo=timezone.utc),
            updated_at=datetime(2025, 1, i+1, tzinfo=timezone.utc),
            version=1
        )
        mock_obj.data = {
            "name": f"test{i}",
            "value": i * 42
        }
        objects.append(mock_obj)
    return objects

@pytest.fixture
def mock_snapshot_file_factory(tmp_path, mock_stored_objects):
    """Factory for creating snapshot files with configurable timestamps."""
    def _create_snapshot(snapshot_time=None, include_objects=None):
        """
        Create a mock snapshot file with configurable timestamp and objects.
        
        Args:
            snapshot_time: Custom snapshot timestamp (defaults to 1 day ago)
            include_objects: List of indices from mock_stored_objects to include
                            (defaults to all objects)
        
        Returns:
            Path to the created snapshot file
        """
        # Default timestamp is 1 day ago
        if snapshot_time is None:
            snapshot_time = datetime.now(timezone.utc) - timedelta(days=1)
        
        snapshot_path = tmp_path / f"snapshot_{int(datetime.now().timestamp())}.json"
        
        # Convert objects to serializable format
        snapshot_data = {
            "snapshot_time": snapshot_time.isoformat(),
            "repository": "owner/repo",
            "objects": {}
        }
        
        # Determine which objects to include
        objects_to_include = mock_stored_objects
        if include_objects is not None:
            # sort of a weird way to go about this...
            objects_to_include = [mock_stored_objects[i] for i in include_objects if i < len(mock_stored_objects)]
        
        # Add objects to snapshot
        for obj in objects_to_include:
            snapshot_data["objects"][obj.meta.object_id] = {
                "data": obj.data,
                "meta": {
                    "object_id": obj.meta.object_id,
                    "issue_number": obj.meta.issue_number,
                    "created_at": obj.meta.created_at.isoformat(),
                    "updated_at": obj.meta.updated_at.isoformat(),
                    "version": obj.meta.version
                }
            }
        
        snapshot_path.write_text(json.dumps(snapshot_data, indent=2))
        return snapshot_path
    
    return _create_snapshot

@pytest.fixture
def mock_snapshot_file(mock_snapshot_file_factory):
    """Create a default mock snapshot file for testing."""
    return mock_snapshot_file_factory()



---
File: tests/unit/fixtures/config.py
---
# tests/unit/fixtures/config.py
"""Configuration fixtures for gh-store unit tests."""

from datetime import datetime, timezone
from pathlib import Path
import pytest
from unittest.mock import patch, mock_open
from omegaconf import OmegaConf

@pytest.fixture
def default_config():
    """Create a consistent default config for testing."""
    return OmegaConf.create({
        "store": {
            "base_label": "stored-object",
            "uid_prefix": "UID:",
            "reactions": {
                "processed": "+1",
                "initial_state": "rocket"
            },
            "retries": {
                "max_attempts": 3,
                "backoff_factor": 2
            },
            "rate_limit": {
                "max_requests_per_hour": 1000
            },
            "log": {
                "level": "INFO",
                "format": "{time} | {level} | {message}"
            }
        }
    })

@pytest.fixture(autouse=True)
def mock_config_file(default_config):
    """Mock OmegaConf config loading."""
    with patch('omegaconf.OmegaConf.load', return_value=default_config) as mock_load:
        yield mock_load

@pytest.fixture
def test_config_dir(tmp_path: Path) -> Path:
    """Provide a temporary directory for config files during testing."""
    config_dir = tmp_path / ".config" / "gh-store"
    config_dir.mkdir(parents=True)
    return config_dir

@pytest.fixture
def test_config_file(test_config_dir: Path, default_config: OmegaConf) -> Path:
    """Create a test config file with minimal valid content."""
    config_path = test_config_dir / "config.yml"
    config_path.write_text(OmegaConf.to_yaml(default_config))
    return config_path



---
File: tests/unit/fixtures/github.py
---
# tests/unit/fixtures/github.py
"""GitHub API mocks for gh-store unit tests."""

from datetime import datetime, timezone
import json
from typing import Any, Callable, Literal, TypedDict
import pytest
from unittest.mock import Mock, patch
from github import GithubException

from gh_store.core.constants import LabelNames

@pytest.fixture
def mock_label_factory():
    """
    Create GitHub-style label objects.
    
    Example:
        label = mock_label_factory("enhancement")
        label = mock_label_factory("bug", "fc2929")
        label = mock_label_factory("bug", "fc2929", "Bug description")
    """
    def create_label(name: str, color: str = "0366d6", description: str = None) -> Mock:
        """
        Create a mock label with GitHub-like structure.
        
        Args:
            name: Name of the label
            color: Color hex code without #
            description: Optional description for the label
        """
        label = Mock()
        label.name = name
        label.color = color
        label.description = description
        return label
    
    return create_label

class CommentMetadata(TypedDict, total=False):
    """Metadata for comment creation."""
    client_version: str
    timestamp: str
    update_mode: Literal['append', 'replace']

class CommentBody(TypedDict, total=False):
    """Structure for comment body data."""
    _data: dict[str, Any]
    _meta: CommentMetadata
    type: Literal['initial_state'] | None

@pytest.fixture
def mock_comment_factory():
    """
    Create GitHub comment mocks with standard structure.

    This factory creates mock comment objects that mirror GitHub's API structure,
    with proper typing and validation for reactions and metadata.

    Args in create_comment:
        body: Comment body (dict will be JSON serialized)
        user_login: GitHub username of comment author
        comment_id: Unique comment ID (auto-generated if None)
        reactions: List of reaction types or mock reactions
        created_at: Comment creation timestamp
        **kwargs: Additional attributes to set on the comment

    Examples:
        # Basic comment with data
        comment = mock_comment_factory(
            body={"value": 42},
            user_login="owner"
        )

        # Comment with metadata
        comment = mock_comment_factory(
            body={
                "_data": {"value": 42},
                "_meta": {
                    "client_version": "0.5.1",
                    "timestamp": "2025-01-01T00:00:00Z",
                    "update_mode": "append"
                }
            }
        )

        # Initial state comment
        comment = mock_comment_factory(
            body={
                "type": "initial_state",
                "_data": {"initial": "state"},
                "_meta": {
                    "client_version": "0.5.1",
                    "timestamp": "2025-01-01T00:00:00Z",
                    "update_mode": "append"
                }
            }
        )

        # Comment with reactions
        comment = mock_comment_factory(
            body={"value": 42},
            reactions=["+1", "rocket"]
        )
    """
    def create_comment(
        body: dict[str, Any] | CommentBody,
        user_login: str = "repo-owner",
        comment_id: int | None = None,
        reactions: list[str | Mock] | None = None,
        created_at: datetime | None = None,
        **kwargs
    ) -> Mock:
        """Create a mock comment with GitHub-like structure."""
        # Validate body structure if it's meant to be a CommentBody
        if isinstance(body, dict) and "_meta" in body:
            if "update_mode" in body["_meta"] and body["_meta"]["update_mode"] not in ["append", "replace"]:
                raise ValueError("update_mode must be 'append' or 'replace'")
            if "type" in body and body["type"] not in [None, "initial_state"]:
                raise ValueError("type must be None or 'initial_state'")

        comment = Mock()
        
        # Set basic attributes
        comment.id = comment_id or 1
        comment.body = json.dumps(body)
        comment.created_at = created_at or datetime(2025, 1, 1, tzinfo=timezone.utc)
        
        # Set up user
        user = Mock()
        user.login = user_login
        comment.user = user
        
        # Set up reactions with validation
        mock_reactions = []
        if reactions:
            for reaction in reactions:
                if isinstance(reaction, Mock):
                    if not hasattr(reaction, 'content'):
                        raise ValueError("Mock reaction must have 'content' attribute")
                    mock_reactions.append(reaction)
                else:
                    mock_reaction = Mock()
                    mock_reaction.content = str(reaction)
                    mock_reactions.append(mock_reaction)
        
        comment.get_reactions = Mock(return_value=mock_reactions)
        comment.create_reaction = Mock()
        
        # Add any additional attributes
        for key, value in kwargs.items():
            setattr(comment, key, value)
        
        return comment
    
    return create_comment


mock_comment = mock_comment_factory


@pytest.fixture
def mock_issue_factory(mock_comment_factory, mock_label_factory):
    """
    Create GitHub issue mocks with standard structure.

    Examples:
        # Basic issue
        issue = mock_issue_factory(
            body={"test": "data"}
        )

        # Issue with explicit number
        issue = mock_issue_factory(
            number=123,
            labels=["stored-object", "UID:test-123"]
        )

        # Issue with comments
        issue = mock_issue_factory(
            comments=[
                mock_comment_factory(
                    body={"value": 42},
                    comment_id=1
                )
            ]
        )
    """
    def create_issue(
        number: int | None = None,
        body: dict[str, Any] | str | None = None,
        labels: list[str] | None = None,
        comments: list[Mock] | None = None,
        state: str = "closed",
        user_login: str = "repo-owner",
        created_at: datetime | None = None,
        updated_at: datetime | None = None,
        **kwargs
    ) -> Mock:
        """
        Create a mock issue with GitHub-like structure.

        Args:
            number: Issue number (defaults to 1 if not provided)
            body: Issue body content (dict will be JSON serialized)
            labels: List of label names to add
            comments: List of mock comments
            state: Issue state (open/closed)
            user_login: GitHub username of issue creator
            created_at: Issue creation timestamp
            updated_at: Issue last update timestamp
            **kwargs: Additional attributes to set
        """
        issue = Mock()
        
        # Set basic attributes
        issue.number = number or 1  # Default to 1 if not provided
        issue.body = json.dumps(body) if isinstance(body, dict) else (body or "{}")
        issue.state = state
        issue.created_at = created_at or datetime(2025, 1, 1, tzinfo=timezone.utc)
        issue.updated_at = updated_at or datetime(2025, 1, 2, tzinfo=timezone.utc)
        
        # Set up user
        user = Mock()
        user.login = user_login
        issue.user = user
        
        # Set up labels
        issue_labels = []
        issue.labels = issue_labels
        if labels:
            for label_name in labels:
                issue.labels.append(mock_label_factory(label_name))
                #issue.labels.append(label_name)
        
        
        # Set up comments
        mock_comments = list(comments) if comments is not None else []
        issue.get_comments = Mock(return_value=mock_comments)
        issue.create_comment = Mock()

        # Set up proper owner permissions
        repo = Mock()
        owner = Mock()
        owner.login = user_login
        owner.type = "User"
        repo.owner = owner
        issue.repository = repo  # Needed for access control checks
        
        # Set up issue editing
        issue.edit = Mock()
        
        # Add any additional attributes
        for key, value in kwargs.items():
            setattr(issue, key, value)
        
        return issue
    
    return create_issue

# Keep backward compatibility
mock_issue = mock_issue_factory


@pytest.fixture
def mock_repo_factory(mock_label_factory):
    """
    Create GitHub repository mocks with standard structure.
    
    Note: Creates basic repository structure. Labels, issues, and permissions
    should be explicitly set up in tests where they matter.
    """
    def create_repo(
        name: str = "owner/repo",
        owner_login: str = "repo-owner",
        owner_type: str = "User",
        labels: list[str] | None = None,
        issues: list[Mock] | None = None,
        **kwargs
    ) -> Mock:
        """
        Create a mock repository with GitHub-like structure.
        Args:
            name: Repository name in owner/repo format
            owner_login: Repository owner's login
            owner_type: Owner type ("User" or "Organization")
            labels: Initial repository labels
            issues: Initial repository issues
            **kwargs: Additional attributes to set
        """
        repo = Mock()
        
        # Set basic attributes
        repo.full_name = name
        
        # Set up owner - making it more explicit
        owner = Mock(spec=['login', 'type'])  # Specify expected attributes
        owner.login = owner_login
        owner.type = owner_type
        repo.owner = owner
        
        # Set up labels - include gh-store by default unless specified otherwise
        repo_labels = []
        if labels:
            default_labels = [LabelNames.GH_STORE.value, LabelNames.STORED_OBJECT.value] \
                                if LabelNames.GH_STORE.value not in labels and LabelNames.STORED_OBJECT.value not in labels else []
            for name in default_labels + labels:
                repo_labels.append(mock_label_factory(name))
        repo.get_labels = Mock(return_value=repo_labels)
        
        # Set up label creation
        def create_label(name: str, color: str = "0366d6", description: str = None) -> Mock:
            label = mock_label_factory(name, color, description)
            repo_labels.append(label)
            return label
        repo.create_label = Mock(side_effect=create_label)
        
        # Set up issues
        repo_issues = issues or []
        def get_issue(number):
            matching = [i for i in repo_issues if i.number == number]
            if matching:
                return matching[0]
            mock_issue = Mock()
            mock_issue.state = "closed"
            return mock_issue
        repo.get_issue = Mock(side_effect=get_issue)
        repo.get_issues = Mock(return_value=repo_issues)
        
        # Set up CODEOWNERS handling
        def get_contents(path: str) -> Mock:
            if path in ['.github/CODEOWNERS', 'docs/CODEOWNERS', 'CODEOWNERS']:
                content = Mock()
                content.decoded_content = f"* @{owner_login}".encode()
                return content
            raise GithubException(404, "Not found")
        repo.get_contents = Mock(side_effect=get_contents)
        
        # Add any additional attributes
        for key, value in kwargs.items():
            setattr(repo, key, value)
        
        return repo
    
    return create_repo

@pytest.fixture
def mock_github():
    """Create a mock Github instance with proper repository structure."""
    with patch('gh_store.core.store.Github') as mock_gh:
        # Setup mock repo
        mock_repo = Mock()
        
        # Setup owner
        owner = Mock()
        owner.login = "repo-owner"
        owner.type = "User"
        mock_repo.owner = owner
        
        # Setup labels
        mock_labels = [Mock(name=LabelNames.STORED_OBJECT.value), Mock(name=LabelNames.GH_STORE.value)]
        mock_repo.get_labels = Mock(return_value=mock_labels)
        
        def create_label(name: str, color: str = "0366d6") -> Mock:
            new_label = Mock(name=name)
            mock_labels.append(new_label)
            return new_label
        mock_repo.create_label = Mock(side_effect=create_label)
        
        # Mock CODEOWNERS access
        mock_content = Mock()
        mock_content.decoded_content = b"* @repo-owner"
        def get_contents_side_effect(path: str) -> Mock:
            if path in ['.github/CODEOWNERS', 'docs/CODEOWNERS', 'CODEOWNERS']:
                return mock_content
            raise GithubException(404, "Not found")
        mock_repo.get_contents = Mock(side_effect=get_contents_side_effect)
        
        mock_gh.return_value.get_repo.return_value = mock_repo
        yield mock_gh, mock_repo



---
File: tests/unit/fixtures/store.py
---
# tests/unit/fixtures/store.py
"""Store-related fixtures for gh-store unit tests."""

from datetime import datetime, timezone
from typing import Sequence
from unittest.mock import Mock, patch

import pytest

from gh_store.core.constants import LabelNames
from gh_store.core.exceptions import ObjectNotFound
from gh_store.core.store import GitHubStore
from gh_store.core.version import CLIENT_VERSION


def setup_mock_auth(store, authorized_users: Sequence[str] | None = None):
    """Set up mocked authorization for testing.
    
    Args:
        store: GitHubStore instance to configure
        authorized_users: List of usernames to authorize (defaults to ['repo-owner'])
    """
    if authorized_users is None:
        authorized_users = ['repo-owner']
    
    # Pre-populate owner info cache
    store.access_control._owner_info = {
        'login': 'repo-owner',
        'type': 'User'
    }
    
    # If we have additional authorized users via CODEOWNERS
    if len(authorized_users) > 1:
        # Mock CODEOWNERS content
        codeowners_content = "* " + " ".join(f"@{user}" for user in authorized_users)
        mock_content = Mock()
        mock_content.decoded_content = codeowners_content.encode()
        store.repo.get_contents = Mock(return_value=mock_content)
        
        # Clear codeowners cache to force reload
        store.access_control._codeowners = None


@pytest.fixture
def store(mock_repo_factory, default_config):
    """Create GitHubStore instance with mocked dependencies."""
    repo = mock_repo_factory(
        name="owner/repo",
        owner_login="repo-owner",
        owner_type="User",
        labels=[LabelNames.GH_STORE.value, LabelNames.STORED_OBJECT.value]
    )
    
    with patch('gh_store.core.store.Github') as mock_gh:
        mock_gh.return_value.get_repo.return_value = repo
        
        store = GitHubStore(token="fake-token", repo="owner/repo")
        store.repo = repo
        store.access_control.repo = repo
        store.config = default_config
        
        # Set up default authorization
        setup_mock_auth(store)
        
        return store

@pytest.fixture
def authorized_store(store):
    """Create store with additional authorized users for testing."""
    def _authorized_store(authorized_users: Sequence[str]):
        setup_mock_auth(store, authorized_users=authorized_users)
        return store
    return _authorized_store


@pytest.fixture
def history_mock_comments(mock_comment):
    """Create series of comments representing object history."""
    comments = []
    
    # Initial state
    comments.append(mock_comment(
        user_login="repo-owner",
        body={
            "type": "initial_state",
            "_data": {"name": "test", "value": 42},
            "_meta": {
                "client_version": CLIENT_VERSION,
                "timestamp": "2025-01-01T00:00:00Z",
                "update_mode": "append",
                "issue_number": 123,
            }
        },
        comment_id=1,
        created_at=datetime(2025, 1, 1, tzinfo=timezone.utc)
    ))
    
    # First update
    comments.append(mock_comment(
        user_login="repo-owner",
        body={
            "_data": {"value": 43},
            "_meta": {
                "client_version": CLIENT_VERSION,
                "timestamp": "2025-01-02T00:00:00Z",
                "update_mode": "append",
                "issue_number": 123,
            }
        },
        comment_id=2,
        created_at=datetime(2025, 1, 2, tzinfo=timezone.utc)
    ))
    
    # Second update
    comments.append(mock_comment(
        user_login="repo-owner",
        body={
            "_data": {"value": 44},
            "_meta": {
                "client_version": CLIENT_VERSION,
                "timestamp": "2025-01-03T00:00:00Z",
                "update_mode": "append",
                "issue_number": 123,
            }
        },
        comment_id=3,
        created_at=datetime(2025, 1, 3, tzinfo=timezone.utc)
    ))
    
    return comments


